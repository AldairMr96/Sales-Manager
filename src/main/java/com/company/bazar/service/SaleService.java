package com.company.bazar.service;import com.company.bazar.dto.CreateSaleDTO;import com.company.bazar.dto.MaxSaleDTO;import com.company.bazar.dto.ProductSaleDTO;import com.company.bazar.dto.SaleDTO;import com.company.bazar.model.Client;import com.company.bazar.model.Product;import com.company.bazar.model.Sale;import com.company.bazar.model.SaleProduct;import com.company.bazar.repository.IClientRepository;import com.company.bazar.repository.IProductRepository;import com.company.bazar.repository.ISaleProductRepository;import com.company.bazar.repository.ISaleRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.sql.DatabaseMetaData;import java.time.LocalDate;import java.util.ArrayList;import java.util.Comparator;import java.util.List;import java.util.Optional;import java.util.stream.Collectors;@Servicepublic class SaleService implements ISaleService {    @Autowired    ISaleRepository saleRepository;    @Autowired    IClientRepository clientRepository;    @Autowired    IProductRepository productRepository;    @Autowired    ISaleProductRepository saleProductRepository;    @Override    public void createSale(CreateSaleDTO sale) {        //find client associated a sale        Client client = clientRepository.findById(sale.getIdClient()).                orElseThrow( ()-> new RuntimeException("Client not found"));        //Create sale        Sale newSale = new Sale();        newSale.setClient(client);        //set purchase date with the system date        newSale.setSaleDate(LocalDate.now());        newSale = saleRepository.save(newSale);        double acumulator = 0; //accumulator for the calculate price total sale        for (ProductSaleDTO productSaleRequest : sale.getProductList()) {            Product product = productRepository.findById(productSaleRequest.getProductId()).orElse(null);            //Validate avalible stock            if(product.getStock()> productSaleRequest.getQuantity()) {                SaleProduct saleProduct = new SaleProduct();                saleProduct.setSale(newSale);                saleProduct.setProduct(product);                saleProduct.setQuantity(productSaleRequest.getQuantity());                saleProductRepository.save(saleProduct);                acumulator += (saleProduct.getQuantity() * product.getCost());                //Update Stock product                product.setStock(product.getStock()- productSaleRequest.getQuantity());                productRepository.save(product);            }else {                throw new RuntimeException(" Inavalible Stock: " + product.getNameProduct());            }        }        newSale.setTotalSale(acumulator);        saleRepository.save(newSale);    }    @Override    public List<Sale> getSales() {        List<Sale> saleList = saleRepository.findAll();        return saleList;    }    @Override    public Sale findSale(Long codSale) {        return saleRepository.findById(codSale).                orElseThrow( ()-> new RuntimeException("Client not found"));    }    @Override    public void deleteSale(Long codSale) {        if(!saleRepository.existsById(codSale)){            throw new RuntimeException("Sale not found");        }        saleRepository.deleteById(codSale);    }    @Override    public void editSale(CreateSaleDTO sale) {       Sale saleFound =this.findSale(sale.getIdClient());       List<ProductSaleDTO> newProductSaleList = saleFound.getProducts().stream()               .map(saleProduct -> {                   ProductSaleDTO productSaleDTO = new ProductSaleDTO();                   productSaleDTO.setProductId(saleProduct.getProduct().getCodProduct());                   productSaleDTO.setQuantity(saleProduct.getQuantity());                   return productSaleDTO; })               //Add names in the list               .collect(Collectors.toList());;       //update data sale        CreateSaleDTO  newSale = new CreateSaleDTO(                saleFound.getClient().getIdClient(),                newProductSaleList);        this.createSale(sale);    }    @Override    public List<String> findProductSale(Long codSale) {        //find sale        Sale sale =  this.findSale(codSale);        //Get product list to sale        List<SaleProduct> producSaletList = sale.getProducts();        //map  list and find names of products for sale        List<String> productListName = producSaletList.stream()                .map(saleProduct -> saleProduct.getProduct().getNameProduct())                //Add names in the list                .collect(Collectors.toList());       return productListName;    }    @Override    public SaleDTO totalSale(LocalDate dateSale) {        List<Sale> sales = saleRepository.findBySaleDate(dateSale);        //map totals on sales list and add them        double totalSales = sales.stream().mapToDouble(Sale::getTotalSale).sum();        List<Long> saleIds = sales.stream().map(Sale::getCodSale).toList();        List<SaleProduct> saleProducts = saleProductRepository.findBySale_CodSaleIn(saleIds);        SaleDTO saleDTO = new SaleDTO(totalSales, saleProducts.size());        return saleDTO;    }    @Override    public MaxSaleDTO saleMajor() {       Sale sale=  saleRepository.findSaleWithMaxTotal();       MaxSaleDTO maxSaleDTO = new MaxSaleDTO(sale.getCodSale(),              sale.getTotalSale(),              sale.getProducts().size(),              sale.getClient().getNameClient(),              sale.getClient().getLastnameClient()              );        return maxSaleDTO;    }}